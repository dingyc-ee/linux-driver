# 中断

## 第1章 `GIC`与`NVIC`

以前在stm32单片机中，用的是`NVIC`中断控制器。但是在linux系统中，用的是`GIC`控制器。为什么linux系统不用`NVIC`呢？二者有什么联系与区别。

### 1.1 硬件架构的差异

#### 1.1.1 目标处理器系列不同

+ `NVIC`：转为Cortex-M系列设计，如stm32、ESP32。面向低功耗、实时性强的单片机场景
+ `GIC`：转为Cortex-A系列设计，如Cortex-A系列，面向高性能、多核、复杂外设管理的Linux/Android系统

关键点：Cortex-A处理器的硬件架构中原生继承GIC，而非NVIC。

#### 1.1.2 中断管理规模

NVIC：

+ 最多支持240个外设中断，适合简单外设（`GPIO、UART、ADC`）
+ 中断类型单一，仅支持外设中断和内核异常（`Systick`）

GIC：

+ 支持SPI（共享外设中断）、PPI（私有外设中断）和SGI（软件生成中断）
+ GICv2支持最多1020个中断（SPI 32~1019），适配复杂外设（`PCIe、USB3、千兆网卡`）

现在Soc可能集成数百个外设，NVIC的240中断上限无法满足需求。

### 1.2 多核系统的支持

#### 1.2.1 GIC的多核特性

+ 中断路由与负载均衡：GIC的`Distributor`模块，可将SPI中断动态分发到不同CPU核心，优化负载（如网络中断绑定到空闲CPU）
+ 核间通信：通过SGI发送核间中断，触发其他CPU核心的动作（如任务调度）

#### 1.2.2 NVIC的局限性

NVIC只能适用于单核CPU。

### 1.3 中断类型与功能扩展

#### 1.3.1 GIC的细分中断类型

| 中断类型 | 功能 | Linux应用场景 |
| - | - |
| SPI | 共享外设中断（如网卡、磁盘） | 多核共享外设的中断处理 |
| PPI | CPU私有中断（如本地定时器） | 每核独立的时钟中断 |
| SGI | 软件生成中断（核间通信）） | 多核任务调度 |

#### 1.3.2 NVIC的单一中断类型

+ 所有外设中断统一管理，缺乏SPI、PPI/SGI的细分，无法支持多和系统的精细管理
+ 例如：CortexM的Systick定时器中断时全局的，无法绑定到特定的CPU核心

### 1.4 性能与实时性对比

#### 1.4.1 NVIC的实时性优势

+ 中断响应延时极低（通常<10周期），适合硬实时系统（如电机控制）
+ 原因：NVIC直接集成在Cortex-M内核中，无需通过总线访问外部控制器

#### 1.4.2 GIC的吞吐量优势

+ 通过多核分发和优先级抢占，支持高并发中断处理（如数据中心网卡的 100 万+ PPS）
+ 示例：GIC 可将多个网卡队列的中断分发到不同 CPU 核心，避免单核瓶颈

### 1.5 总结

ARM Linux为何必须使用GIC？

+ 硬件强制要求：Cortex-A处理器原生集成GIC，无法替换为NVIC
+ 多核支持：GIC的SPI-SGI中断机制，是Linux多核调度核负载均衡的基础
+ 扩展性需求：GIC支持上千个中断核虚拟化，适配复杂外设核云计算场景
+ Linux内核依赖：设备树、电源管理等特性深度绑定GIC功能

最终结论：

+ NVIC是为资源受限的单片机设计，适合实时操作系统（`FreeRTOS`）
+ 高性能多和系统设计的，是Linux在Cortex-A平台上的唯一选择。两者服务于不同的生态位，不可互换。


