# 输入子系统

## 第1章 初识输入子系统

Linux输入子系统是Linux内核中，用于*统一管理各种输入设备*(键盘、鼠标、触摸屏、游戏手柄)的框架。它将这些设备产生的原始信号转换为系统可识别的标准事件，并传递给应用程序。

![](./src/0001.jpg)

下面是Linux输入子系统支持的主要事件类型及其含义：

| 事件类型(`Event Type`) | 含义 | 典型设备 | 常见事件码(`Event Code`) |
| - | - | - | - |
| `EV_KEY`(0x01) | 按键事件 | 键盘、按钮 | `KEY_ENTER`(回车键)、`KEY_SPACE`(空格键)、`KEY_A`(A键) |
| `EV_REL`(0x02) | 相对位移事件，报告相对于上一次位置的偏移量 | 鼠标 | `REL_X`(X轴移动)、`REL_Y`(Y轴移动)、`REL_WHEEL`(滚轮) |
| `EV_ABS`(0x03) | 绝对位移事件，报告在一个绝对坐标系中的位置 | 触摸屏 | `ABS_X`(X坐标)、`ABS_Y`(Y坐标)、`ABS_PRESSURE`(压力) |
| `EV_SYN`(0x00) | 同步事件，用于分隔或打包一系列输入事件，标志一个事件报告的结束 | 所有设备 | `SYN_REPORT`(报告同步)、`SYN_CONFIG`(配置同步) |
| `EV_MSC`(0x04) | 其他事件类型 | 多种设备 | `MSC_SCAN`(扫描码) |
| `EV_SW`(0x05) | 开关事件 | 开关、拨码开关 | `SW_LID`(笔记本盖子开关) |
| `EV_LED`(0x11) | LED灯状态事件 | 键盘LED | `LED_NUML`(数字键盘锁LED)、`LED_CAPSL`(大写锁LED) |

输入子系统的工作流程：

Linux输入子系统采用分层架构，主要分为三层。各司其职：

| 层级 | 职责描述 | 关键操作/函数 |
| - | - | - |
| 驱动层 | 直接与硬件交互，读取原始数据，并将其转换为标准的`input_event` | 申请和注册输入设备(`input_allocate_device`、`input_register_device`)、上报事件(`input_event`、`input_report_*`) |
| 核心层 | 承上启下，提供输入设备和事件处理程序的注册和管理接口，负责将事件分发给正确的处理程序 | 提供统一的设备管理和事件分发机制 |
| 事件处理层 | 接收核心层分发的事件，并将其传递到用户空间应用程序(通常通过`/dev/input/eventX`设备文件) | 为应用程序提供统一的`read`接口读取事件 |

这种*分层解耦*的设计思路带来了诸多好处：

+ *对驱动开发者*：只需关注硬件操作和事件上报，无需关心事件如何传递到应用
+ *对应用开发者*：只需从统一的设备文件读取标准格式的事件，无需关心底层硬件差异
+ *对系统*：增强了可扩展性和可维护性，新硬件只需实现驱动层即可接入整个系统

典型使用场景：

Linux输入子系统广泛应用于多种场景：

+ *桌面环境*：管理键盘、鼠标、触摸板，为用户提供图形界面(如GNOME)交互的基础
+ *嵌入式系统*：在智能电视、工业控制面板、智能家居中控等设备上，处理触摸屏、五年间、遥控器信号等输入
+ *移动设备*：智能手机和平板电脑中，驱动触摸屏、传感器(如重力感应)、物理音量键
+ *游戏和娱乐*： 支持游戏手柄、摇杆、方向盘等游戏外设
+ *服务器和无人值守设备*：虽然交互不多，但仍可能需要处理键盘输入等基本操作

编写一个简单的输入设备驱动：

了解输入子系统的设计后，若要编写一个简单的输入设备驱动(如GPIO按键)。核心步骤包括：

1. *分配输入设备*：使用`input_allocate_device()`分配一个`struct input_dev`
2. *设置设备能力*：使用`set_bit()`告诉内核设备支持哪些事件类型(如`EV_KEY`)和具体事件(如`KEY_A`)
3. *注册输入设备*：使用`input_register_device()`将设备注册到子系统
4. *上报输入事件*：在中断处理函数或轮询例程中，检测到输入动作(按键按下/释放)时，使用`input_report_key()`等函数上报事件，并以`input_sync()`同步标记事件结束
5. *注销和清理*：在驱动卸载时，使用`input_unregister_device()`和`input_free_device()`进行清理


